# -*- coding: utf-8 -*-
"""Capstone_review-3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tLnT-pRrqTtUkCGK7gVq2BIiVf6WlW6h
"""

import warnings
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random
import math
from decimal import *

df=pd.read_excel('sample_data/PB-4.xlsx')

number_of_Machines = df.shape[1]-1

row_header = ['Operations']
for i in range(number_of_Machines):
  row_header.insert(i+1,'M'+ str(i+1))

df.columns = row_header


df = df.iloc[1:,:]

df=df.dropna(how='all')

df=df.replace(np.nan,999)

NullList=[]
for index in range(df.shape[0]):
  row = df.iloc[index:index+1,:].values.flatten().tolist()
  NullList.append(row.count(999))
print(NullList)

df

data = df.copy()


data=data.iloc[:,1:]
data

priority_rowHeader = ['Operations']
for i in range(number_of_Machines):
  priority_rowHeader.insert(i+1,'Priority - '+ str(i+1))
print(priority_rowHeader)

priority_df = pd.DataFrame(columns=priority_rowHeader)
priority_df



for index in range(df.shape[0]):
  row = df.iloc[index:index+1,:].values.flatten().tolist()


  priority_row = np.argsort(row[1:])

  priority_row = [x + 1 for x in priority_row]


  priority_row.insert(0,row[0])


  priority_df = priority_df.append(pd.DataFrame([priority_row],columns = priority_rowHeader),ignore_index=True)
  print(priority_row)

priority_df

for col in priority_rowHeader[1:]:
  priority_df[col] = priority_df[col].astype(int)

priority_df

n=300


operations = df.iloc[:,0:1].values.flatten().tolist()

print(operations)

def NumberOfOperationsInEachJob():
  j=1
  count=0
  number_of_Operations_inEachJob_List=[]

  for i in operations:
    if(int(str(i)[0:len(str(j))])==j):
      count+=1
    else:
      number_of_Operations_inEachJob_List.append(count)
      j+=1
      count=1

    if(i==operations[-1]):
      number_of_Operations_inEachJob_List.append(count)

  return number_of_Operations_inEachJob_List

def returnFloatOperationsInJobs():

  number_of_Operations_inEachJob_List=NumberOfOperationsInEachJob()
  numberofJobs = len(number_of_Operations_inEachJob_List)

  b = 1
  FloatOperationList=[]
  duplicate_operations = operations.copy()
  for job in range(1,numberofJobs+1):
    a=0
    for operation in duplicate_operations:
      if(int(str(operation)[0:len(str(job))])==job):
        z = (len(str(int(operation)))-len(str(job)))
        b = operation/10**z
        if(z==1):
          b = str(b)
          index = b.index('.') +1
          b = b[:index] + '0' + b[index:]
          b=float(b)
        FloatOperationList.append(b)
        a=a+1
      else:
        break
    duplicate_operations = duplicate_operations[a:]

  df['Operations'] = FloatOperationList
  priority_df['Operations'] = FloatOperationList
  return number_of_Operations_inEachJob_List,FloatOperationList

number_of_Operations_inEachJob_List,FloatOperationList = returnFloatOperationsInJobs()
numberofJobs = len(number_of_Operations_inEachJob_List)

def generateValueList():
  valueList = pd.DataFrame(columns=FloatOperationList)
  for i in range(n):
    randomList=[]
    for j in range(len(operations)):
      randomNumber = round(random.uniform(1.0001,1+number_of_Machines-NullList[j]-0.0001),4)
      randomList.append(randomNumber)
    valueList = valueList.append(pd.DataFrame([randomList],columns = FloatOperationList),ignore_index=True)
  return valueList

Value_df = generateValueList()
(Value_df)

def returnIntegerAndFractionList(valueList):

  integerList = pd.DataFrame(columns=FloatOperationList)
  fractionList = pd.DataFrame(columns=FloatOperationList)

  for index in range(n):
    valueListRow = valueList.iloc[index:index+1,:].values.flatten().tolist()

    integerRow = [int(value) for value in valueListRow]
    fractionRow = [value-int(value) for value in valueListRow]

    integerList = integerList.append(pd.DataFrame([integerRow],columns = FloatOperationList),ignore_index=True)
    fractionList = fractionList.append(pd.DataFrame([fractionRow],columns = FloatOperationList),ignore_index=True)
  return integerList,fractionList

Integer_df,Fraction_df = returnIntegerAndFractionList(Value_df)
(Integer_df)

def MachineSwap(valueList):
  integerList = pd.DataFrame(columns=FloatOperationList)
  valueListNew = pd.DataFrame(columns=FloatOperationList)
  for index in range(n):
    valueListRow = valueList.iloc[index:index+1,:].values.flatten().tolist()

    integerRow = [int(value) for value in valueListRow]
    for i in range(len(integerRow)):
      if(integerRow[i]>1):
        integerRow[i]-=1
        valueListRow[i]-=1
    integerList = integerList.append(pd.DataFrame([integerRow],columns = FloatOperationList),ignore_index=True)
    valueListNew = valueListNew.append(pd.DataFrame([valueListRow],columns = FloatOperationList),ignore_index=True)
  return integerList,valueListNew

Integer_df2 = Integer_df
Value_df_New = Value_df

#Integer_df2,Value_df_New = MachineSwap(Value_df)

# cumilative list in the fraction value in operations
def getCumulativeList(list):
  cumulativeList = []
  j=0
  for i in range(0,len(list)):
    j+=list[i]
    cumulativeList.append(j)
  return cumulativeList

OperationsCumulativeList = getCumulativeList(number_of_Operations_inEachJob_List)
print(OperationsCumulativeList)

#  sorting the fractions in the operations and adding to the integer
def returnFeasibleList(integerList,fractionList,cumulativeList):

  feasibleList = pd.DataFrame(columns = FloatOperationList)

  for index in range(n):

    row = fractionList.iloc[index:index+1,:].values.flatten().tolist()
    fractionListAfterSorting=[]
    row = [ round(elem, 4) for elem in row ]

    for i in range(numberofJobs):

      if(i==0):
        ListforSorting =  row[0:cumulativeList[i]]
      else:
        ListforSorting =  row[cumulativeList[i-1]:cumulativeList[i]]

      ListforSorting = sorted(ListforSorting)
      fractionListAfterSorting.extend(ListforSorting)

    integer = integerList.iloc[index:index+1,:].values.flatten().tolist()

    for i in range(len(row)):
      integer[i] = integer[i] + fractionListAfterSorting[i]
    feasibleList = feasibleList.append(pd.DataFrame([integer],columns = FloatOperationList),ignore_index=True)
  return feasibleList

Feasible_df = returnFeasibleList(Integer_df,Fraction_df,OperationsCumulativeList)
(Feasible_df)

Feasible_df2 = returnFeasibleList(Integer_df2,Fraction_df,OperationsCumulativeList)

def returnFractionFromFeasibleList(feasibleList):
  fractionList = pd.DataFrame(columns=FloatOperationList)

  for index in range(n):

    row = feasibleList.iloc[index:index+1,:].values.flatten().tolist()
    fractionRow = [val-int(val) for val in row]
    fractionList = fractionList.append(pd.DataFrame([fractionRow],columns = FloatOperationList),ignore_index=True)

  return fractionList

FractionAfterSorting_df = returnFractionFromFeasibleList(Feasible_df)
(FractionAfterSorting_df)

FractionAfterSorting_df2 = returnFractionFromFeasibleList(Feasible_df2)

def generateMatrix(sequence,startTimeMatrix,EndTimeMatrix):
  Operations_on_Each_Machine_List = [sequence[i] for i in sequence]

  completedList=[]
  waitTimeForEachMachineList = [0] * number_of_Machines

  while(get_length(Operations_on_Each_Machine_List)!=0):

    Operations_on_Each_Machine_List = [sequence[i] for i in sequence]
    firstColumn =[]

    for j in range(len(Operations_on_Each_Machine_List)):
      if(len(Operations_on_Each_Machine_List[j])!=0):
        firstColumn.append(Operations_on_Each_Machine_List[j][0])
      else:
        firstColumn.append(0.0)


    length_CompletedList = len(completedList)

    for operation in firstColumn:
      y = len(str(operation).split('.')[1])
      b = (0.1)**y
      a = (Decimal(str(operation)) - Decimal(str(b)))
      if((float(a) in completedList) or int(str(operation).split('.')[1])==1):
        #print(operation)
        time = (data.iloc[FloatOperationList.index(operation):FloatOperationList.index(operation)+1,firstColumn.index(operation):firstColumn.index(operation)+1].values.flatten()[0])
        row = int(operation) - 1
        x = str(operation).split('.')[1]
        col = int(x) - 1
        Machine = firstColumn.index(operation)

        if(col==0):
          startTimeMatrix[row][col] = max(waitTimeForEachMachineList[Machine],0)
          EndTimeMatrix[row][col] = startTimeMatrix[row][col] + time
        else:
          startTimeMatrix[row][col] = max(EndTimeMatrix[row][col-1],waitTimeForEachMachineList[Machine])
        EndTimeMatrix[row][col] = startTimeMatrix[row][col] + time
        waitTimeForEachMachineList[Machine] = EndTimeMatrix[row][col]
        #print("waitTimeForEachMachineList :"+str(waitTimeForEachMachineList))
        completedList.append(operation)

        ExecutedOperation = sequence[firstColumn.index(operation)+1]
        ExecutedOperation.pop(0)
        sequence[firstColumn.index(operation)+1] = ExecutedOperation

        #print(completedList,ExecutedOperation,firstColumn.index(operation)+1,sequence[firstColumn.index(operation)+1])
        #print(sequence)
    if(len(completedList) == length_CompletedList):
      DoSequenceSwap(sequence)
  return completedList

def MakeSpan(minMakeSpan,maxMakeSpan,FloatOperationList,integerList,fractionList2):
  MakeSpanList=[]

  BestStartTime=[]
  BestEndTime=[]
  BestSequence={}
  BestExecutionList=[]

  WorstStartTime=[]
  WorstEndTime=[]
  WorstSequence={}
  WorstExecutionList=[]

  #AllExecutionLists=[]
  #AllLists=[]

  BestIndex=0
  WorstIndex=0

  for index in range(n):
    print(index)
    initialSequence={}
    initialSequence2={}
    fractionDict={}

    startTimeMatrix = [[0]*max(number_of_Operations_inEachJob_List) for _ in range(len(number_of_Operations_inEachJob_List))]
    EndTimeMatrix = [[0]*max(number_of_Operations_inEachJob_List) for _ in range(len(number_of_Operations_inEachJob_List))]

    integer = integerList.iloc[index:index+1,:].values.flatten().tolist()
    #integer = [1]*len(operations)
    fraction = fractionList2.iloc[index:index+1,:].values.flatten().tolist()
    #integer = [2,1,1,2,3,1,3,1,4]
    #fraction = [0.4356,0.8430, 0.1724,0.2456, 0.5219, 0.2427,  0.3216,0.5842,0.7951]
    fraction = [ round(elem, 4) for elem in fraction ]

    for i in range(len(FloatOperationList)):
      priorityRow = priority_df.iloc[i:i+1,:].values.flatten().tolist()
      Machine = priorityRow[integer[i]]
      if(Machine not in initialSequence.keys()):
        initialSequence[Machine] = [FloatOperationList[i]]
        initialSequence2[Machine] = [FloatOperationList[i]]
        fractionDict[Machine] = [fraction[i]]
      else:
        l=initialSequence[Machine]
        l += [FloatOperationList[i]]
        initialSequence[Machine] = l
        initialSequence2[Machine] = l
        fractionDict[Machine] += [fraction[i]]
    print("List before sorting : " + str(initialSequence))

    for key in initialSequence.keys():
      initialSequence[key] = ([x for y, x in sorted(zip(fractionDict[key], initialSequence[key]))])
      initialSequence2[key] = ([x for y, x in sorted(zip(fractionDict[key], initialSequence2[key]))])

    for i in range(1,number_of_Machines+1):
      if i not in initialSequence.keys():
        #print("i" + str(i))
        initialSequence[i] = []
        initialSequence2[i] = []

    initialSequence = dict(sorted(initialSequence.items()))
    initialSequence2 = dict(sorted(initialSequence2.items()))
    print("List after sorting based on fraction : " + str(initialSequence))

    ExecutionOrder = generateMatrix(initialSequence,startTimeMatrix,EndTimeMatrix)
    #AllExecutionLists.append(ExecutionOrder)

    if((max(list(np.concatenate(EndTimeMatrix))) < minMakeSpan) or index==0):
      BestStartTime = startTimeMatrix
      BestEndTime= EndTimeMatrix
      minMakeSpan = max(list(np.concatenate(EndTimeMatrix)))
      BestSequence= initialSequence2
      BestExecutionList = ExecutionOrder
      BestIndex=index
    if((max(list(np.concatenate(EndTimeMatrix))) > maxMakeSpan) or index==0):
      WorstStartTime = startTimeMatrix
      WorstEndTime= EndTimeMatrix
      maxMakeSpan = max(list(np.concatenate(EndTimeMatrix)))
      WorstSequence= initialSequence2
      WorstExecutionList = ExecutionOrder
      WorstIndex = index
    #AllLists.append(EndTimeMatrix)
    MakeSpanList.append(max(list(np.concatenate(EndTimeMatrix))))
    #print(startTimeMatrix,EndTimeMatrix)
  return MakeSpanList,BestStartTime,BestEndTime,WorstStartTime,WorstEndTime,BestIndex,WorstIndex,BestSequence,WorstSequence,BestExecutionList,WorstExecutionList

def get_length(l):
  n=0
  for j in range(len(l)):
    if(len(l[j])!=0):
      n+=1
  return n

def returnFraction(b):
  m=[]
  q = b.copy()
  for e in b:
    a=Decimal(str(e)) - Decimal(str(int(e)))
    a = ((a)*(10**(len(str(a))-2)))
    m.append(a)
  m = np.argsort(m)
  b=[]
  for e in m:
    b.append(q[e])
  return b

def DoSequenceSwap(sequence):
  for key in sequence.keys():
    values = sequence[key]
    v=values.copy()
    sequence[key] = returnFraction(v)

def getKey(sequence,val):
  for i in sequence.keys():
    l = sequence[i]
    if(val in l):
      return int(i)

def drawGraph(sequence,executionList,minEndTime,startTime,EndTime):
  # Horizontal bar plot with gaps
  fig, ax = plt.subplots()
  ax.set_xlabel('Time')
  ax.set_ylabel('Machines')
  ax.set_xlim(0, minEndTime+1)
  colors = ['yellow','red','orange','green','brown','pink','gray','cyan','purple','olive']
  ax.set_yticks([10*(i+1) for i in range(number_of_Machines)], labels=['M'+str(i+1) for i in range(number_of_Machines) ])
  for k in executionList:
    col = float(Decimal(str(k)) - Decimal(str(int(k))))
    col = int(col * (10 ** (len(str(col))-2)))-1
    row = int(k)-1
    start = startTime[row][col]
    end = EndTime[row][col]
    diff = end-start
    i = getKey(sequence,k)
    ax.text(x = start + (diff)/2, y = 10*i, s = 'O' + str(row+1)+str(col+1), ha='center', va='center',color='black')
    ax.broken_barh([(start,diff)],(10*i-4, 8),edgecolor="black",alpha=1,linewidth=3, facecolors= random.choice(colors))
  #ax.grid(True)
  plt.show()
  f = plt.figure()

minMakeSpan = 0
maxMakeSpan = 0
MakeSpanList,BestStartTime,BestEndTime,WorstStartTime,WorstEndTime,BestIndex,WorstIndex,BestSequence,WorstSequence,BestExecutionList,WorstExecutionList = MakeSpan(minMakeSpan,maxMakeSpan,FloatOperationList,Integer_df,FractionAfterSorting_df)

bestValues = Value_df_New.iloc[BestIndex:BestIndex+1,:].values.flatten().tolist()

for i in range(len(MakeSpanList)):
  print("MakeSpan for ieration {} is {}".format(i,MakeSpanList[i]))

print("The Minimum MakeSpan is {}".format(min(MakeSpanList)))

#print("BEFORE MACHINE SWAP")
drawGraph(BestSequence,BestExecutionList,min(MakeSpanList),BestStartTime,BestEndTime)

BestSequence

min(MakeSpanList)

BestStartTime

BestEndTime

#print("After Machine swap : ")

#minMakeSpan = 0
#maxMakeSpan = 0
#MakeSpanList,BestStartTime,BestEndTime,WorstStartTime,WorstEndTime,BestIndex,WorstIndex,BestSequence,WorstSequence,BestExecutionList,WorstExecutionList = MakeSpan(minMakeSpan,maxMakeSpan,FloatOperationList,Integer_df2,FractionAfterSorting_df2)

#for i in range(len(MakeSpanList)):
  #print("MakeSpan for ieration {} is {}".format(i,MakeSpanList[i]))

#print("The Minimum MakeSpan is {}".format(min(MakeSpanList)))

#print("AFTER MACHINE SWAP")
#drawGraph(BestSequence,BestExecutionList,min(MakeSpanList),BestStartTime,BestEndTime)

#BestStartTime

#BestEndTime

#BestSequence

#BestIndex

#bestValues

def calculateMeanFlowTime(startTime,EndTime,executionList):
  number_of_Operations_inEachJob_List=NumberOfOperationsInEachJob()
  OperationTimeMatrix = [[0]*max(number_of_Operations_inEachJob_List) for _ in range(len(number_of_Operations_inEachJob_List))]
  for i in range(len(number_of_Operations_inEachJob_List)):
    for j in range(max(number_of_Operations_inEachJob_List)):
      OperationTimeMatrix[i][j] = int(EndTime[i][j]-startTime[i][j])
  MeanFlowTimeList = []
  for k in executionList:
    col = float(Decimal(str(k)) - Decimal(str(int(k))))
    col = int(col * (10 ** (len(str(col))-2)))-1
    row = int(k)-1
    MeanFlowTimeList.append(OperationTimeMatrix[row][col])
  return OperationTimeMatrix,MeanFlowTimeList

OperationTimeMatrixBest,MeanFlowTimeListBest = calculateMeanFlowTime(BestStartTime,BestEndTime,BestExecutionList)
#print(MeanFlowTimeListBest,OperationTimeMatrixBest)
OperationTimeMatrixWorst,MeanFlowTimeListWorst = calculateMeanFlowTime(WorstStartTime,WorstEndTime,WorstExecutionList)
#print(MeanFlowTimeListWorst,OperationTimeMatrixWorst)

cumulativeMeanFlowTimeBest = getCumulativeList(MeanFlowTimeListBest)
cumulativeMeanFlowTimeWorst = getCumulativeList(MeanFlowTimeListWorst)
#print(cumulativeMeanFlowTimeBest,cumulativeMeanFlowTimeWorst)

MeanFlowTimeBest =  sum(cumulativeMeanFlowTimeBest)/len(operations)
MeanFlowTimeWorst =  sum(cumulativeMeanFlowTimeWorst)/len(operations)
print("Mean Flow Time : {}".format(round(MeanFlowTimeBest,4)))

print(cumulativeMeanFlowTimeBest)

len(operations)

def ApplyRaoAlgorithm():
  newFeasibleList = pd.DataFrame(columns = np.array(FloatOperationList).astype(str))
  for i in range(n):
    values = bestValues#Value_df_New.iloc[i:i+1,:].values.flatten().tolist()
    a=[]
    for j in range(len(values)):
      p = values[j] + random.uniform(0, 1)*(Value_df_New.iloc[BestIndex:BestIndex+1,:].values.flatten().tolist()[j] - Value_df_New.iloc[WorstIndex:WorstIndex+1,:].values.flatten().tolist()[j] )
      if(p > 1 and p< 1 + number_of_Machines):
        if(p < values[j]):
          a.append(p)
        else:
          a.append(values[j])
      else:
        a.append(values[j])
    newFeasibleList = newFeasibleList.append(pd.DataFrame([a],columns = np.array(FloatOperationList).astype(str)),ignore_index=True)
  return newFeasibleList

iter=1
maxIter=11
min_MakeSpan=[]
FinalStartTime=[]
FinalEndTime=[]
FinalExecutionList=[]
z = min(MakeSpanList)
z1 = min(MakeSpanList)
while(iter<maxIter):
  newFeasibleList = ApplyRaoAlgorithm()
  print(newFeasibleList)
  integerList, fractionList = returnIntegerAndFractionList(newFeasibleList)
  fractionList = returnFractionFromFeasibleList(newFeasibleList)
  minMakeSpan = 0
  maxMakeSpan = 0
  max_EndTime,x,y,maxX,maxY,BestIndex,WorstIndex,sequence,maxSequence,executionList,maxExecutionList = MakeSpan(minMakeSpan,maxMakeSpan,FloatOperationList,integerList,fractionList)
  if((min(max_EndTime)<z) or iter==1):
    z = min(max_EndTime)
    FinalStartTime =x
    FinalEndTime = y
    FinalExecutionList = executionList
  print(max_EndTime)
  min_MakeSpan.append(min(max_EndTime))
  iter+=1

min_MakeSpan

for i in range(len(min_MakeSpan)):
  print("MakeSpan for ieration {} is {}".format(i,min_MakeSpan[i]))

print("The minimum makespan after Roa algorithm is {}".format(min(min_MakeSpan)))

FinalStartTime,FinalEndTime,FinalExecutionList

sequence

for i in sequence.keys():
  val = sequence[i]
  m=[]
  for j in val:
    m.append(FinalExecutionList.index(j))
  val = [i for _,i in sorted(zip(m,val))]
  sequence[i] = val

sequence

drawGraph(sequence,FinalExecutionList,min(min_MakeSpan),FinalStartTime,FinalEndTime)

OperationTimeMatrix,MeanFlowTimeList = calculateMeanFlowTime(FinalStartTime,FinalEndTime,FinalExecutionList)
#print(MeanFlowTimeList,OperationTimeMatrix)

cumulativeMeanFlowTime = getCumulativeList(MeanFlowTimeList)
#print(cumulativeMeanFlowTime)

MeanFlowTime =  sum(cumulativeMeanFlowTime)/len(operations)
print("Mean Flow Time - Rao Algorithm : {}".format(round(MeanFlowTime,4)))

def AOA_Algorithm(z1):
  MOP_Max = 1
  MOP_Min = 0.2
  C_Iter = 1
  Alpha = 5
  Mu = 0.499
  M_Iter = 11
  LB = 1+0.0001
  UB = 1+number_of_Machines-0.0001
  eps = 0
  min_MakeSpan=[]
  minSequence={}
  FinalStartTime=[]
  FinalEndTime=[]
  BestValues_AOA=[]
  FinalExecutionList=[]
  while(C_Iter < M_Iter):
    MOP = 1 - ((C_Iter)**(1 / Alpha) / (M_Iter)**(1 / Alpha))
    MOA = MOP_Min + C_Iter * ((MOP_Max - MOP_Min) / M_Iter)

    newFeasibleList = pd.DataFrame(columns = np.array(FloatOperationList).astype(str))
    for i in range(n):
      #values = bestValues
      values = Value_df_New.iloc[i:i+1,:].values.flatten().tolist()
      a=[]
      for j in range(len(values)):
        r1 = random.random()
        if(r1<MOA):
          r2 = random.random()
          if(r2>0.5):
            p = values[j]*(MOP)*((UB-LB)*Mu + LB)
          else:
            p=values[j]/(MOP + eps)*((UB-LB)*Mu + LB)
        else:
          r3 = random.random()
          if(r3>0.5):
            p= values[j]+(MOP)*((UB-LB)*Mu + LB)
          else:
            p = values[j]-(MOP)*((UB-LB)*Mu + LB)

        if(p >= LB and p <= UB):
          if(p < values[j]):
            a.append(p)
          else:
            a.append(values[j])
        else:
          a.append(values[j])

      newFeasibleList = newFeasibleList.append(pd.DataFrame([a],columns = np.array(FloatOperationList).astype(str)),ignore_index=True)
    integerList2, fractionList = returnIntegerAndFractionList(newFeasibleList)
    fractionList3 = returnFractionFromFeasibleList(newFeasibleList)
    a = 0
    b = 0
    max_EndTime,x,y,maxX,maxY,BestIndex,WorstIndex,sequence,maxSequence,executionList,maxExecutionList = MakeSpan(a,b,FloatOperationList,integerList2,fractionList3)
    if(min(max_EndTime)<z1 or C_Iter==1):
      z1 = min(max_EndTime)
      FinalStartTime =x
      FinalEndTime = y
      minSequence = sequence
      FinalExecutionList = executionList
      BestValues_AOA = newFeasibleList.iloc[BestIndex:BestIndex+1,:].values.flatten().tolist()
    print(max_EndTime)
    min_MakeSpan.append(min(max_EndTime))
    C_Iter+=1
  return min_MakeSpan,FinalStartTime,FinalEndTime,FinalExecutionList,minSequence,BestValues_AOA

z1=0
min_MakeSpan_AOA,FinalStartTime_AOA,FinalEndTime_AOA,FinalExecutionList_AOA,sequence_AOA,BestValues_AOA = AOA_Algorithm(z1)

BestValues_AOA = [ round(elem, 4) for elem in BestValues_AOA ]
BestValues_AOA

print(min(min_MakeSpan_AOA))

sequence_AOA

drawGraph(sequence_AOA,FinalExecutionList_AOA,min(min_MakeSpan_AOA),FinalStartTime_AOA,FinalEndTime_AOA)

OperationTimeMatrix,MeanFlowTimeList = calculateMeanFlowTime(FinalStartTime_AOA,FinalEndTime_AOA,FinalExecutionList_AOA)
#print(MeanFlowTimeList,OperationTimeMatrix)

cumulativeMeanFlowTime = getCumulativeList(MeanFlowTimeList)
#print(cumulativeMeanFlowTime)

MeanFlowTime =  sum(cumulativeMeanFlowTime)/len(operations)
print("Mean Flow Time - AOA Algorithm: {}".format(round(MeanFlowTime,4)))

print("start Time Matrix")
for i in FinalStartTime_AOA:
  print(i)

print("End Time Matrix")
for i in FinalEndTime_AOA:
  print(i)

FinalExecutionList_AOA

print("Execution List")
for i in sequence_AOA.keys():
  print(i , sequence_AOA[i])

sequence_AOA

for i in sequence_AOA.keys():
  val = sequence_AOA[i]
  m=[]
  for j in val:
    m.append(FinalExecutionList_AOA.index(j))
  val = [i for _,i in sorted(zip(m,val))]
  sequence_AOA[i] = val

sequence_AOA